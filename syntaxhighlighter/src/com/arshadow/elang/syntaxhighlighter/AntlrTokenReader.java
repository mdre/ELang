package com.arshadow.elang.syntaxhighlighter;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * This class reads in a file generated by ANTLR and uses it to automatically tell NetBeans which words should have colored highlighting. For example,
 * keywords will show up blue, by default.
 *
 * @author Andreas Stefik
 */
public class AntlrTokenReader {

    private HashMap<String, String> tokenTypes = new HashMap<String, String>();
    private ArrayList<ETokenId> tokens = new ArrayList<ETokenId>();

    public AntlrTokenReader() {
        init();
    }

    /**
     * Initializes the map to include any keywords in the Hop Programming language.
     */
    private void init() {

        /*
         Grupos de tokens
         * number
         * comment
         * char
         * keyword
         * operator
         * 
         */

//         - ANYWS tok: 6
// - CHAR_LITERAL tok: 21
// - DOC_COMMENT tok: 36
// - EOL tok: 45
// - ESC tok: 46
// - EXPONENT tok: 51
// - FLOAT64 tok: 56
 //- HEX tok: 64
// - HEX_DIGIT tok: 65
// - IDENT tok: 68
// - LINESEP tok: 79
// - Line_comment tok: 80
 //- LiteralString tok: 81
 //- OCTAL tok: 92
// - POSINT tok: 128
// - QUASI1 tok: 133
// - QUASIBODY tok: 134
// - QUASIn tok: 135
// - URI tok: 163
// - URIBody tok: 164
// - WS tok: 175
        

        tokenTypes.put("HEX", "number");
        tokenTypes.put("OCTAL", "number");
//WS = 73
//LINESEP = 74
        tokenTypes.put("Line_comment", "comment");
        tokenTypes.put("DOC_COMMENT", "comment");
        tokenTypes.put("CHAR_LITERAL", "char");
        tokenTypes.put("LiteralString", "string");
//ESC = 79
        tokenTypes.put("HEX_DIGIT", "number");
        tokenTypes.put("IDENT", "id");
        tokenTypes.put("POSINT", "number");
        tokenTypes.put("FLOAT64", "number");
        tokenTypes.put("EXPONENT", "number");
        
        tokenTypes.put("QUASI1", "quasi");
        tokenTypes.put("QUASIBODY", "quasi");
        tokenTypes.put("QUASIn", "quasi");
        
        tokenTypes.put("URI", "uri");
        tokenTypes.put("URIBody", "uri");
        
        
//";"=86
        tokenTypes.put("pragma", "keyword"); // = "pragma" = 87
//"."=88
        tokenTypes.put("meta", "keyword"); // = "meta" = 89
        tokenTypes.put("if", "keyword"); // = "if" = 90
        tokenTypes.put("else", "keyword"); // = "else" = 91
        tokenTypes.put("for", "keyword"); // = "for" = 92
        tokenTypes.put("in", "keyword"); //= "in" = 93
        tokenTypes.put("=>", "operator"); // =94
        tokenTypes.put("accum", "keyword"); // = "accum" = 95
        tokenTypes.put("while", "keyword"); // = "while" = 96
        tokenTypes.put("{", "block"); // =97
        tokenTypes.put("_", "keyword"); // = "_" = 98
        tokenTypes.put("+", "operator"); // =99
        tokenTypes.put("*", "operator"); // =100
        tokenTypes.put("&", "operator"); // =101
        tokenTypes.put("|", "operator"); // =102
        tokenTypes.put("when", "keyword"); // = "when" = 103
        tokenTypes.put("->", "operator"); // =104
        tokenTypes.put("finally", "keyword"); // = "finally" = 105
//":"=106
//escape = "escape" = 107
        tokenTypes.put("thunk", "keyword"); // = "thunk" = 108
        tokenTypes.put("fn", "keyword"); // = "fn" = 109
        tokenTypes.put("switch", "keyword"); // = "switch" = 110
        tokenTypes.put("try", "keyword"); // = "try" = 111
        tokenTypes.put("bind", "keyword"); // = "bind" = 112
        tokenTypes.put("var", "keyword"); // = "var" = 113
        tokenTypes.put("def", "keyword"); // = "def" = 114
        tokenTypes.put(":=", "operator"); // =115
        tokenTypes.put("(", "block"); // =116
//","=117
        tokenTypes.put(")", "block"); // =118
        tokenTypes.put("extends", "keyword"); // = "extends" = 119
        tokenTypes.put("implements", "keyword"); // = "implements" = 120
        tokenTypes.put("to", "keyword"); // = "to" = 121
        tokenTypes.put("method", "keyword"); // = "method" = 122
        tokenTypes.put("on", "keyword"); // = "on" = 123
        tokenTypes.put("match", "keyword"); // = "match" = 124
        tokenTypes.put("throws", "keyword"); // = "throws" = 125
        tokenTypes.put("interface", "keyword"); // = "interface" = 126
        tokenTypes.put("guards", "keyword"); // = "guards" = 127
        tokenTypes.put("=", "operator"); // =128
        tokenTypes.put("//=", "operator"); // =129
        tokenTypes.put("+=", "operator"); // =130
        tokenTypes.put("-=", "operator"); // =131
        tokenTypes.put("*=", "operator"); // =132
        tokenTypes.put("/=", "operator"); // =133
        tokenTypes.put("%=", "operator"); // =134
        tokenTypes.put("%%=", "operator"); // =135
        tokenTypes.put("**=", "operator"); // =136
        tokenTypes.put(">>=", "operator"); // =137
        tokenTypes.put("<<=", "operator"); //=138
        tokenTypes.put("&=", "operator"); // =139
        tokenTypes.put("^=", "operator"); // =140
        tokenTypes.put("|=", "operator"); // =141
        tokenTypes.put("break", "keyword"); // = "break" = 142
        tokenTypes.put("continue", "keyword"); // = "continue" = 143
        tokenTypes.put("return", "keyword"); // = "return" = 144
        tokenTypes.put("^", "operator"); // =145
        tokenTypes.put("||", "operator"); // =146
        tokenTypes.put("&&", "operator"); // =147
        tokenTypes.put("==", "operator"); // =148
        tokenTypes.put("!=", "operator"); // =149
        tokenTypes.put("&!", "operator"); // =150
        tokenTypes.put("=~", "operator"); // =151
        tokenTypes.put("!~", "operator"); // =152
        tokenTypes.put("<", "operator"); // =153
        tokenTypes.put("<=", "operator"); // =154
        tokenTypes.put("<=>", "operator"); // =155
        tokenTypes.put(">=", "operator"); // =156
        tokenTypes.put(">", "operator"); // =157
        tokenTypes.put("..", "operator"); // =158
        tokenTypes.put("..!", "operator"); // =159
        tokenTypes.put("<<", "operator"); // =160
        tokenTypes.put(">>", "operator"); // =161
        tokenTypes.put("-", "operator"); // =162
        tokenTypes.put("/", "operator"); // =163
        tokenTypes.put("//", "operator"); // =164
        tokenTypes.put("%", "operator"); // =165
        tokenTypes.put("%%", "operator"); // =166
        tokenTypes.put("**", "operator"); // =167
        tokenTypes.put("!", "operator"); // =168
        tokenTypes.put("~", "operator"); // =169
        tokenTypes.put("[", "block"); // =170
        tokenTypes.put("]", "block"); // =171
        tokenTypes.put("<-", "operator"); // =172
        tokenTypes.put("::", "operator"); // =173
        tokenTypes.put("catch", "keyword"); // // = "catch" = 174
        tokenTypes.put("?", "operator"); // =175
        tokenTypes.put("${", "block"); // =176
        tokenTypes.put("$", "operator"); // =177
        tokenTypes.put("$$", "operator"); // =178
        tokenTypes.put("@{", "block"); // =179
        tokenTypes.put("@", "operator"); // =180
        tokenTypes.put("abstract", "keyword"); // // = "abstract" = 181
        tokenTypes.put("an", "keyword"); // // = "an" = 182
        tokenTypes.put("as", "keyword"); // // = "as" = 183
        tokenTypes.put("assert", "keyword"); // // = "assert" = 184
        tokenTypes.put("attribute", "keyword"); // // = "attribute" = 185
        tokenTypes.put("be", "keyword"); // // = "be" = 186
        tokenTypes.put("begin", "keyword"); // // = "begin" = 187
        tokenTypes.put("behalf", "keyword"); // // = "behalf" = 188
        tokenTypes.put("belief", "keyword"); // // = "belief" = 189
        tokenTypes.put("believe", "keyword"); // // = "believe" = 190
        tokenTypes.put("believes", "keyword"); // // = "believes" = 191
        tokenTypes.put("case", "keyword"); // // = "case" = 192
        tokenTypes.put("class", "keyword"); // // = "class" = 193
        tokenTypes.put("const", "keyword"); // // = "const" = 194
        tokenTypes.put("constructor", "keyword"); // // = "constructor" = 195
        tokenTypes.put("datatype", "keyword"); // // = "datatype" = 196
        tokenTypes.put("declare", "keyword"); // // = "declare" = 197
        tokenTypes.put("default", "keyword"); // // = "default" = 198
        tokenTypes.put("define", "keyword"); // // = "define" = 199
        tokenTypes.put("defmacro", "keyword"); // // = "defmacro" = 200
        tokenTypes.put("delicate", "keyword"); // // = "delicate" = 201
        tokenTypes.put("deprecated", "keyword"); // // = "deprecated" = 202
        tokenTypes.put("dispatch", "keyword"); // // = "dispatch" = 203
        tokenTypes.put("do", "keyword"); // // = "do" = 204
        tokenTypes.put("encapsulate", "keyword"); // // = "encapsulate" = 205
        tokenTypes.put("encapsulated", "keyword"); // // = "encapsulated" = 206
        tokenTypes.put("encapsulates", "keyword"); // // = "encapsulates" = 207
        tokenTypes.put("end", "keyword"); // // = "end" = 208
        tokenTypes.put("ensure", "keyword"); // // = "ensure" = 209
        tokenTypes.put("enum", "keyword"); // // = "enum" = 210
        tokenTypes.put("eventual", "keyword"); // // = "eventual" = 211
        tokenTypes.put("eventually", "keyword"); // // = "eventually" = 212
        tokenTypes.put("export", "keyword"); // // = "export" = 213
        tokenTypes.put("facet", "keyword"); // // = "facet" = 214
        tokenTypes.put("forall", "keyword"); // // = "forall" = 215
        tokenTypes.put("fun", "keyword"); // // = "fun" = 216
        tokenTypes.put("function", "keyword"); // // = "function" = 217
        tokenTypes.put("given", "keyword"); // // = "given" = 218
        tokenTypes.put("hidden", "keyword"); // // = "hidden" = 219
        tokenTypes.put("hides", "keyword"); // // = "hides" = 220
        tokenTypes.put("inline", "keyword"); // // = "inline" = 221
        tokenTypes.put("know", "keyword"); // // = "know" = 222
        tokenTypes.put("knows", "keyword"); // // = "knows" = 223
        tokenTypes.put("lambda", "keyword"); // // = "lambda" = 224
        tokenTypes.put("let", "keyword"); // // = "let" = 225
        tokenTypes.put("methods", "keyword"); // // = "methods" = 226
        tokenTypes.put("namespace", "keyword"); // // = "namespace" = 227
        tokenTypes.put("native", "keyword"); // // = "native" = 228
        tokenTypes.put("obeys", "keyword"); // // = "obeys" = 229
        tokenTypes.put("octet", "keyword"); // // = "octet" = 230
        tokenTypes.put("oneway", "keyword"); // // = "oneway" = 231
        tokenTypes.put("operator", "keyword"); // // = "operator" = 232
        tokenTypes.put("package", "keyword"); // // = "package" = 233
        tokenTypes.put("private", "keyword"); // // = "private" = 234
        tokenTypes.put("protected", "keyword"); // // = "protected" = 235
        tokenTypes.put("public", "keyword"); // // = "public" = 236
        tokenTypes.put("raises", "keyword"); // // = "raises" = 237
        tokenTypes.put("reliance", "keyword"); // // = "reliance" = 238
        tokenTypes.put("reliant", "keyword"); // // = "reliant" = 239
        tokenTypes.put("relies", "keyword"); // // = "relies" = 240
        tokenTypes.put("rely", "keyword"); // // = "rely" = 241
        tokenTypes.put("reveal", "keyword"); // // = "reveal" = 242
        tokenTypes.put("sake", "keyword"); // // = "sake" = 243
        tokenTypes.put("signed", "keyword"); // // = "signed" = 244
        tokenTypes.put("static", "keyword"); // // = "static" = 245
        tokenTypes.put("struct", "keyword"); // // = "struct" = 246
        tokenTypes.put("suchthat", "keyword"); // // = "suchthat" = 247
        tokenTypes.put("supports", "keyword"); // // = "supports" = 248
        tokenTypes.put("suspect", "keyword"); // // = "suspect" = 249
        tokenTypes.put("suspects", "keyword"); // // = "suspects" = 250
        tokenTypes.put("synchronized", "keyword"); // // = "synchronized" = 251
        tokenTypes.put("this", "keyword"); // // = "this" = 252
        tokenTypes.put("transient", "keyword"); // // = "transient" = 253
        tokenTypes.put("truncatable", "keyword"); // // = "truncatable" = 254
        tokenTypes.put("typedef", "keyword"); // // = "typedef" = 255
        tokenTypes.put("unsigned", "keyword"); // // = "unsigned" = 256
        tokenTypes.put("unum", "keyword"); // // = "unum" = 257
        tokenTypes.put("uses", "keyword"); // // = "uses" = 258
        tokenTypes.put("using", "keyword"); // // = "using" = 259
        tokenTypes.put("utf8", "keyword"); // //=260
        tokenTypes.put("utf16", "keyword"); // //=261
        tokenTypes.put("virtual", "keyword"); // // = "virtual" = 262
        tokenTypes.put("volatile", "keyword"); // // = "volatile" = 263
        tokenTypes.put("wstring", "keyword"); // // = "wstring" = 264


        /*
         tokenTypes.put("TYPE_INT", "type");
         tokenTypes.put("TYPE_CHAR", "type");

         tokenTypes.put("FOR", "keyword");

         tokenTypes.put("ID", "identifier");
         tokenTypes.put("INT", "number");
         */
    }

    /**
     * Reads the token file from the ANTLR parser and generates appropriate tokens.
     *
     * @return
     */
    public List<ETokenId> readTokenFile() {
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        InputStream inp = classLoader.getResourceAsStream("com/arshadow/elang/syntaxhighlighter/utils/e.tokens");
        BufferedReader input = new BufferedReader(new InputStreamReader(inp));
        readTokenFile(input);
        return tokens;
    }

    /**
     * Reads in the token file.
     *
     * @param buff
     */
    private void readTokenFile(BufferedReader buff) {
        String line = null;
        try {
            while ((line = buff.readLine()) != null) {
                if (line.trim() != null) {
//                String[] splLine = line.split("=");
//                    System.out.print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> " + line);
                    int idx = line.lastIndexOf("=");
                    String name = line.substring(0, idx).replace("'", "");
                    // si no comienza con un ' multiplicar el id por 1000 para evitar el id duplicado
                    int tok = Integer.parseInt(line.substring(idx + 1));
//                    System.out.println(" - "+name+" tok: "+tok);
                    
                    // si el token ya fue agregado ignorarlo
                    boolean found = false;
                    for (ETokenId eTokenId : tokens) {
                        if (eTokenId.ordinal() == tok) {
                            found = true;
                        }
                    }
                    
                    if (!found) {
                        System.out.println(" - "+name+" tok: "+tok);
                        ETokenId id;
                        String tokenCategory = tokenTypes.get(name);
                        if (tokenCategory != null) {
                            //if the value exists, put it in the correct category
                            id = new ETokenId(name, tokenCategory, tok);
                        } else {
                            //if we don't recognize the token, consider it to a separator
                            id = new ETokenId(name, "separator", tok);
                        }
                        //add it into the vector of tokens
                        tokens.add(id);
                    }
                }
            }
//            System.out.println("finalizado!");
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }
}
